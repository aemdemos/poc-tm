#!/usr/bin/env node

/**
 * Build query-index.json from local content HTML files.
 *
 * Scans all .html files (excluding .plain.html) in content/,
 * extracts metadata from <meta> tags, and writes query-index.json.
 *
 * Usage:
 *   node build-query-index.js
 */

const fs = require('fs');
const path = require('path');
const { JSDOM } = require('jsdom');

const CONTENT_DIR = path.join(__dirname, '../../content');
const OUTPUT_PATH = path.join(CONTENT_DIR, 'query-index.json');

function findHtmlFiles(dir) {
  const files = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // Skip resources index itself and drafts
      if (entry.name === 'drafts') continue;
      files.push(...findHtmlFiles(fullPath));
    } else if (entry.name.endsWith('.html') && !entry.name.endsWith('.plain.html')) {
      files.push(fullPath);
    }
  }

  return files;
}

function extractMetadata(htmlPath) {
  const html = fs.readFileSync(htmlPath, 'utf8');
  const dom = new JSDOM(html);
  const doc = dom.window.document;

  // EDS stores metadata in a <div class="metadata"> block within the body.
  // Each key-value pair is a nested div structure:
  //   <div class="metadata"><div><div>key</div><div>value</div></div>...</div>
  const metadataBlock = doc.querySelector('.metadata');
  const metaMap = {};
  if (metadataBlock) {
    // Find all divs that contain exactly two child divs (key-value pairs).
    // The metadata block may have a wrapper div, so search all nested divs.
    const allDivs = metadataBlock.querySelectorAll('div');
    allDivs.forEach((div) => {
      const children = div.querySelectorAll(':scope > div');
      if (children.length === 2) {
        const key = (children[0].textContent || '').trim().toLowerCase();
        const value = (children[1].textContent || '').trim();
        if (key && value && key.length < 30) {
          metaMap[key] = value;
        }
      }
    });
  }

  // Also check <meta> tags in case the file was generated by aem up
  const getMetaTag = (name) => {
    const el = doc.querySelector(`meta[name="${name}"]`);
    return el ? el.getAttribute('content') || '' : '';
  };

  const getMeta = (name) => metaMap[name] || getMetaTag(name) || '';

  // Build the path for this resource (relative URL)
  const relativePath = path.relative(CONTENT_DIR, htmlPath);
  const urlPath = '/content/' + relativePath.replace(/\.html$/, '').replace(/\\/g, '/');

  // Try to get title from metadata block, then from H1, then from <title>
  let title = getMeta('title');
  if (!title) {
    const h1 = doc.querySelector('h1');
    if (h1) title = h1.textContent.trim();
  }
  if (!title) {
    const titleEl = doc.querySelector('title');
    if (titleEl) title = titleEl.textContent.trim();
  }

  // Skip pages without a title (probably not real content)
  if (!title) return null;

  return {
    path: urlPath,
    title,
    description: getMeta('description'),
    image: getMeta('image'),
    date: getMeta('date'),
    author: getMeta('author'),
    tags: getMeta('tags'),
    template: getMeta('template'),
    lastModified: Math.floor(fs.statSync(htmlPath).mtimeMs / 1000),
  };
}

function main() {
  console.log('Building query-index.json from local content...');

  const htmlFiles = findHtmlFiles(CONTENT_DIR);
  console.log(`Found ${htmlFiles.length} HTML files`);

  const data = [];

  for (const file of htmlFiles) {
    try {
      const entry = extractMetadata(file);
      if (entry) {
        data.push(entry);
      }
    } catch (err) {
      console.error(`  Error processing ${path.relative(CONTENT_DIR, file)}: ${err.message}`);
    }
  }

  // Sort by date descending (newest first), then by title
  data.sort((a, b) => {
    if (a.date && b.date) {
      return b.date.localeCompare(a.date);
    }
    if (a.date) return -1;
    if (b.date) return 1;
    return a.title.localeCompare(b.title);
  });

  const output = {
    total: data.length,
    offset: 0,
    limit: data.length,
    data,
    ':type': 'sheet',
  };

  fs.writeFileSync(OUTPUT_PATH, JSON.stringify(output, null, 2), 'utf8');
  console.log(`\nGenerated ${OUTPUT_PATH}`);
  console.log(`Total entries: ${data.length}`);

  // Print template breakdown
  const templates = {};
  data.forEach((d) => {
    const t = d.template || '(none)';
    templates[t] = (templates[t] || 0) + 1;
  });
  console.log('\nBy template:');
  Object.entries(templates).sort((a, b) => b[1] - a[1]).forEach(([t, c]) => {
    console.log(`  ${t}: ${c}`);
  });

  // Print tag breakdown (top 20)
  const tagCounts = {};
  data.forEach((d) => {
    if (d.tags) {
      d.tags.split(',').map((t) => t.trim()).filter(Boolean).forEach((tag) => {
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      });
    }
  });
  const topTags = Object.entries(tagCounts).sort((a, b) => b[1] - a[1]).slice(0, 20);
  console.log('\nTop 20 tags:');
  topTags.forEach(([tag, count]) => {
    console.log(`  ${tag}: ${count}`);
  });
}

main();
